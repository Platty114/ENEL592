regex pattern for cwe-1271 and occurance stats for each SoC analyzed

------------------------------------- regex pattern ----------------------------------------

  logic lock_jtag;

  always_ff @(posedge clk) begin
    //lock_jtag value is unkown at startup / on reset
    //potentially starting as a 1, allowing the system to be written when it
    //shouldn't
    if (en) lock_jtag <= lock_input;
  end 

  always_ff @(posedge clk) begin 
    if(reset) 
      o_data <= 5'b00000;
    else if(lock_jtag)
      o_data <= wr_data;
  end

this vulnerability is related to a lock signal not being set a known value on reset. In the 
above implementation, on reset, the value of lock_jtag is unknown, potentially allowing 
for a write to occur to o_data, even if it shouldn't be allowed. To detect the number 
of occurances of this pattern, we can first find the number of signals written to using
an enable signal, and then remove the number that don't feature an associated reset clause.
This can be found using the following two regexs.

find all instances of a gaurded assignment in a flip flop:
if *[(]+[~a-zA-Z0-9_\-\.]+[)]+ *[~a-zA-Z0-9_\-\.]+ * <= *[~a-zA-Z0-9_\-\.]+

find all instances of a gaurded assignment in a flip flop that have possibly a reset before:
if *[(]+[~a-zA-Z0-9_\-\.]+[)]+ *[~a-zA-Z0-9_\-\.]+ * <= *[~a-zA-Z0-9_\-\.']+ *;[ *|\n]*else if *[(]+[~a-zA-Z0-9_\-\.]+[)]+ *[~a-zA-Z0-9_\-\.]+ * <= *[~a-zA-Z0-9_\-\.]+

----------------------------------- occurance stats -----------------------------------------
